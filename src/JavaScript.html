<script>
  function toggleTheme() {
    const body = document.body;
    const btn = document.getElementById("themeBtn");

    // Check if we are forcing dark mode currently, or if system is dark and we haven't set a class
    const isSystemDark = window.matchMedia(
      "(prefers-color-scheme: dark)"
    ).matches;
    const isDarkClass = body.classList.contains("dark-mode");
    const isLightClass = body.classList.contains("light-mode");

    let targetMode = "dark";

    if (isDarkClass) {
      targetMode = "light";
    } else if (isLightClass) {
      targetMode = "dark";
    } else {
      // No class set, using system preference
      targetMode = isSystemDark ? "light" : "dark";
    }

    body.classList.remove("dark-mode", "light-mode");
    body.classList.add(targetMode + "-mode");

    btn.textContent = targetMode === "dark" ? "‚òÄÔ∏è Light" : "üåô Dark";
  }

  function clearBoard() {
    const pasteArea = document.getElementById("pasteArea");
    pasteArea.innerHTML = ""; // Wipes the content
    pasteArea.focus(); // Puts cursor back in the box immediately
    showToast("Board cleared");
  }

  async function convertAndCopy() {
    const pasteArea = document.getElementById("pasteArea");

    const markdown = parseNode(pasteArea).trim();

    if (!markdown) {
      showToast("Please paste some text first.", true);
      return;
    }

    try {
      await navigator.clipboard.writeText(markdown);
      showToast("Markdown copied to clipboard!");
    } catch (err) {
      console.error("Failed to copy: ", err);
      showToast("Failed to copy. Check permissions.", true);
    }
  }

  function showToast(message, isError = false) {
    const x = document.getElementById("toast");
    x.textContent = message;
    x.style.backgroundColor = isError ? "#ef4444" : "#333";
    x.className = "show";
    setTimeout(function () {
      x.className = x.className.replace("show", "");
    }, 3000);
  }

  /**
   * Recursive function to convert HTML DOM nodes to Markdown
   * Now detects "Visual" code blocks (Divs/Paragraphs with Monospace font)
   */
  function parseNode(node, isPre = false) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent;
    }

    if (node.nodeType !== Node.ELEMENT_NODE) {
      return "";
    }

    const tagName = node.tagName.toLowerCase();
    const style = window.getComputedStyle(node);

    // 1. Detect Monospace Font (Courier, Consolas, Mono)
    const fontFamily = style.fontFamily.toLowerCase();
    const isMonospace =
      fontFamily.includes("courier") ||
      fontFamily.includes("consolas") ||
      fontFamily.includes("mono");

    // 2. Identify "Block" Code
    // It is a block if it's a <pre> OR if it's a <div>/<p> with Monospace font.
    const isBlockMono =
      tagName === "pre" ||
      ((tagName === "div" || tagName === "p") && isMonospace);

    // 3. Determine if we are *currently* inside a code block
    // We pass this down to children to stop them from formatting links/bold etc.
    const currentIsPre = isPre || isBlockMono;

    let content = "";
    // Recursively process child nodes
    for (let child of node.childNodes) {
      content += parseNode(child, currentIsPre);
    }

    // 4. If we are inside a PRE block (inherited), return plain text immediately.
    // This strips links, bold, italics, and PREVENTS inner backticks.
    if (isPre) {
      if (tagName === "br") return "\n";
      if (tagName === "p" || tagName === "div") return content + "\n";
      return content;
    }

    // 5. If this node IS the block wrapper, return the Markdown Code Block
    if (isBlockMono) {
      // We trim to avoid huge gaps, then wrap in triple backticks
      return `\n\`\`\`\n${content.trim()}\n\`\`\`\n`;
    }

    // --- Standard Formatting (Only runs if NOT in a code block) ---

    const fontWeight = style.fontWeight;
    const fontStyle = style.fontStyle;

    // Bold
    if (
      tagName === "b" ||
      tagName === "strong" ||
      parseInt(fontWeight) >= 700
    ) {
      if (!content.startsWith("**")) content = `**${content}**`;
    }

    // Italic
    if (tagName === "i" || tagName === "em" || fontStyle === "italic") {
      if (!content.startsWith("*")) content = `*${content}*`;
    }

    // Strikethrough
    if (
      style.textDecorationLine.includes("line-through") ||
      tagName === "s" ||
      tagName === "strike"
    ) {
      content = `~~${content}~~`;
    }

    // Links
    if (tagName === "a" && node.href) {
      return `[${content}](${node.href})`;
    }

    // --- Block Elements ---

    if (tagName === "p" || tagName === "div") {
      if (content.trim() === "") return "\n";
      return content + "\n\n";
    }

    if (tagName === "br") {
      return "\n";
    }

    // Headings
    if (["h1", "h2", "h3", "h4", "h5", "h6"].includes(tagName)) {
      const level = parseInt(tagName.substring(1));
      return `${"#".repeat(level)} ${content}\n\n`;
    }

    // Lists
    if (tagName === "li") {
      const parent = node.parentElement;
      if (parent.tagName.toLowerCase() === "ol") {
        return `1. ${content}\n`;
      } else {
        return `- ${content}\n`;
      }
    }

    if (tagName === "ul" || tagName === "ol") {
      return content + "\n";
    }

    // Tables
    if (tagName === "tr") {
      return `|${content}\n`;
    }
    if (tagName === "td" || tagName === "th") {
      return ` ${content.trim()} |`;
    }
    if (tagName === "table") {
      return "\n" + content + "\n";
    }

    // Inline Code (Fallback)
    // Only runs if it wasn't caught by the "Block Mono" check above.
    // e.g. a single word in a sentence.
    if (tagName === "code" || isMonospace) {
      if (!content.startsWith("`")) {
        content = `\`${content}\``;
      }
    }

    return content;
  }
</script>
